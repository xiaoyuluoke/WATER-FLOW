; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\rtc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=..\obj\rtc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\main -I..\component\delay -I..\component\LED -I..\component\sys -I..\component\usart -I..\STM32_lib\CORE -I..\STM32_lib\inc -I..\STM32_lib\user_layer -I..\component\KEY -I..\component\lcd_driver -I..\component\gui -I..\component\UI -I..\component\RTC -I..\component\FreeRTOS\Source\include -I..\component\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\component\FreeRTOS -I..\component\FreeRTOS\Source\portable\MemMang -I..\component\FreeRTOS\Source\CMSIS_RTOS -I..\component\STMFLASH -I..\component\PWM_in -IE:\1.项目\1.水流量计\water_FLOW\project\RTE -ID:\1.Software_\5.Keil5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\1.Software_\5.Keil5\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -Dwater_flow --omf_browse=..\obj\rtc.crf ..\component\RTC\rtc.c]
                          THUMB

                          AREA ||i.Is_Leap_Year||, CODE, READONLY, ALIGN=1

                  Is_Leap_Year PROC
;;;103    //输出:该年份是不是闰年.1,是.0,不是
;;;104    u8 Is_Leap_Year(u16 year)
000000  4601              MOV      r1,r0
;;;105    {			  
;;;106    	if(year%4==0) //必须能被4整除
000002  17ca              ASRS     r2,r1,#31
000004  eb017292          ADD      r2,r1,r2,LSR #30
000008  1092              ASRS     r2,r2,#2
00000a  eba10282          SUB      r2,r1,r2,LSL #2
00000e  b992              CBNZ     r2,|L1.54|
;;;107    	{ 
;;;108    		if(year%100==0) 
000010  2064              MOVS     r0,#0x64
000012  fb91f2f0          SDIV     r2,r1,r0
000016  fb001012          MLS      r0,r0,r2,r1
00001a  b950              CBNZ     r0,|L1.50|
;;;109    		{ 
;;;110    			if(year%400==0)return 1;//如果以00结尾,还要能被400整除 	   
00001c  f44f70c8          MOV      r0,#0x190
000020  fb91f2f0          SDIV     r2,r1,r0
000024  fb001012          MLS      r0,r0,r2,r1
000028  b908              CBNZ     r0,|L1.46|
00002a  2001              MOVS     r0,#1
                  |L1.44|
;;;111    			else return 0;   
;;;112    		}else return 1;   
;;;113    	}else return 0;	
;;;114    }	 			   
00002c  4770              BX       lr
                  |L1.46|
00002e  2000              MOVS     r0,#0                 ;111
000030  e7fc              B        |L1.44|
                  |L1.50|
000032  2001              MOVS     r0,#1                 ;112
000034  e7fa              B        |L1.44|
                  |L1.54|
000036  2000              MOVS     r0,#0                 ;113
000038  e7f8              B        |L1.44|
;;;115    //设置时钟
                          ENDP


                          AREA ||i.RTC_Alarm_Set||, CODE, READONLY, ALIGN=2

                  RTC_Alarm_Set PROC
;;;157    //返回值:0,成功;其他:错误代码.
;;;158    u8 RTC_Alarm_Set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;159    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;160    	u16 t;
;;;161    	u32 seccount=0;
000010  2400              MOVS     r4,#0
;;;162    	if(syear<1970||syear>2099)return 1;	   
000012  f24070b2          MOV      r0,#0x7b2
000016  4286              CMP      r6,r0
000018  db03              BLT      |L2.34|
00001a  f6400033          MOV      r0,#0x833
00001e  4286              CMP      r6,r0
000020  dd02              BLE      |L2.40|
                  |L2.34|
000022  2001              MOVS     r0,#1
                  |L2.36|
;;;163    	for(t=1970;t<syear;t++)	//把所有年份的秒钟相加
;;;164    	{
;;;165    		if(Is_Leap_Year(t))seccount+=31622400;//闰年的秒钟数
;;;166    		else seccount+=31536000;			  //平年的秒钟数
;;;167    	}
;;;168    	smon-=1;
;;;169    	for(t=0;t<smon;t++)	   //把前面月份的秒钟数相加
;;;170    	{
;;;171    		seccount+=(u32)mon_table[t]*86400;//月份秒钟数相加
;;;172    		if(Is_Leap_Year(syear)&&t==1)seccount+=86400;//闰年2月份增加一天的秒钟数	   
;;;173    	}
;;;174    	seccount+=(u32)(sday-1)*86400;//把前面日期的秒钟数相加 
;;;175    	seccount+=(u32)hour*3600;//小时秒钟数
;;;176        seccount+=(u32)min*60;	 //分钟秒钟数
;;;177    	seccount+=sec;//最后的秒钟加上去 			    
;;;178    	//设置时钟
;;;179    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);	//使能PWR和BKP外设时钟   
;;;180    	PWR_BackupAccessCmd(ENABLE);	//使能后备寄存器访问  
;;;181    	//上面三步是必须的!
;;;182    	
;;;183    	RTC_SetAlarm(seccount);
;;;184     
;;;185    	RTC_WaitForLastTask();	//等待最近一次对RTC寄存器的写操作完成  	
;;;186    	
;;;187    	return 0;	    
;;;188    }
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L2.40|
000028  f24075b2          MOV      r5,#0x7b2             ;163
00002c  e00a              B        |L2.68|
                  |L2.46|
00002e  4628              MOV      r0,r5                 ;165
000030  f7fffffe          BL       Is_Leap_Year
000034  b110              CBZ      r0,|L2.60|
000036  4820              LDR      r0,|L2.184|
000038  4404              ADD      r4,r4,r0              ;165
00003a  e001              B        |L2.64|
                  |L2.60|
00003c  481f              LDR      r0,|L2.188|
00003e  4404              ADD      r4,r4,r0              ;166
                  |L2.64|
000040  1c68              ADDS     r0,r5,#1              ;163
000042  b285              UXTH     r5,r0                 ;163
                  |L2.68|
000044  42b5              CMP      r5,r6                 ;163
000046  dbf2              BLT      |L2.46|
000048  1e78              SUBS     r0,r7,#1              ;168
00004a  b2c7              UXTB     r7,r0                 ;168
00004c  2500              MOVS     r5,#0                 ;169
00004e  e010              B        |L2.114|
                  |L2.80|
000050  481b              LDR      r0,|L2.192|
000052  5d40              LDRB     r0,[r0,r5]            ;171
000054  f24021a3          MOV      r1,#0x2a3             ;171
000058  4348              MULS     r0,r1,r0              ;171
00005a  eb0414c0          ADD      r4,r4,r0,LSL #7       ;171
00005e  4630              MOV      r0,r6                 ;172
000060  f7fffffe          BL       Is_Leap_Year
000064  b118              CBZ      r0,|L2.110|
000066  2d01              CMP      r5,#1                 ;172
000068  d101              BNE      |L2.110|
00006a  4816              LDR      r0,|L2.196|
00006c  4404              ADD      r4,r4,r0              ;172
                  |L2.110|
00006e  1c68              ADDS     r0,r5,#1              ;169
000070  b285              UXTH     r5,r0                 ;169
                  |L2.114|
000072  42bd              CMP      r5,r7                 ;169
000074  dbec              BLT      |L2.80|
000076  f1a80001          SUB      r0,r8,#1              ;174
00007a  f24021a3          MOV      r1,#0x2a3             ;174
00007e  4348              MULS     r0,r1,r0              ;174
000080  eb0414c0          ADD      r4,r4,r0,LSL #7       ;174
000084  ebc91049          RSB      r0,r9,r9,LSL #5       ;175
000088  ebc02009          RSB      r0,r0,r9,LSL #8       ;175
00008c  eb041400          ADD      r4,r4,r0,LSL #4       ;175
000090  ebca100a          RSB      r0,r10,r10,LSL #4     ;176
000094  eb040480          ADD      r4,r4,r0,LSL #2       ;176
000098  445c              ADD      r4,r4,r11             ;177
00009a  2101              MOVS     r1,#1                 ;179
00009c  f04f50c0          MOV      r0,#0x18000000        ;179
0000a0  f7fffffe          BL       RCC_APB1PeriphClockCmd
0000a4  2001              MOVS     r0,#1                 ;180
0000a6  f7fffffe          BL       PWR_BackupAccessCmd
0000aa  4620              MOV      r0,r4                 ;183
0000ac  f7fffffe          BL       RTC_SetAlarm
0000b0  f7fffffe          BL       RTC_WaitForLastTask
0000b4  2000              MOVS     r0,#0                 ;187
0000b6  e7b5              B        |L2.36|
;;;189    
                          ENDP

                  |L2.184|
                          DCD      0x01e28500
                  |L2.188|
                          DCD      0x01e13380
                  |L2.192|
                          DCD      mon_table
                  |L2.196|
                          DCD      0x00015180

                          AREA ||i.RTC_Get||, CODE, READONLY, ALIGN=2

                  RTC_Get PROC
;;;192    //返回值:0,成功;其他:错误代码.
;;;193    u8 RTC_Get(void)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
;;;195    	static u16 daycnt=0;
;;;196    	u32 timecount=0; 
000002  2600              MOVS     r6,#0
;;;197    	u32 temp=0;
000004  2400              MOVS     r4,#0
;;;198    	u16 temp1=0;	  
000006  2500              MOVS     r5,#0
;;;199        timecount=RTC_GetCounter();	 
000008  f7fffffe          BL       RTC_GetCounter
00000c  4606              MOV      r6,r0
;;;200     	temp=timecount/86400;   //得到天数(秒钟数对应的)
00000e  4838              LDR      r0,|L3.240|
000010  fbb6f4f0          UDIV     r4,r6,r0
;;;201    	if(daycnt!=temp)//超过一天了
000014  4837              LDR      r0,|L3.244|
000016  8800              LDRH     r0,[r0,#0]  ; daycnt
000018  42a0              CMP      r0,r4
00001a  d03c              BEQ      |L3.150|
;;;202    	{	  
;;;203    		daycnt=temp;
00001c  4935              LDR      r1,|L3.244|
00001e  800c              STRH     r4,[r1,#0]
;;;204    		temp1=1970;	//从1970年开始
000020  f24075b2          MOV      r5,#0x7b2
;;;205    		while(temp>=365)
000024  e010              B        |L3.72|
                  |L3.38|
;;;206    		{				 
;;;207    			if(Is_Leap_Year(temp1))//是闰年
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       Is_Leap_Year
00002c  b140              CBZ      r0,|L3.64|
;;;208    			{
;;;209    				if(temp>=366)temp-=366;//闰年的秒钟数
00002e  f5b47fb7          CMP      r4,#0x16e
000032  d302              BCC      |L3.58|
000034  f5a474b7          SUB      r4,r4,#0x16e
000038  e004              B        |L3.68|
                  |L3.58|
;;;210    				else {temp1++;break;}  
00003a  1c68              ADDS     r0,r5,#1
00003c  b285              UXTH     r5,r0
00003e  e006              B        |L3.78|
                  |L3.64|
;;;211    			}
;;;212    			else temp-=365;	  //平年 
000040  f2a4146d          SUB      r4,r4,#0x16d
                  |L3.68|
;;;213    			temp1++;  
000044  1c68              ADDS     r0,r5,#1
000046  b285              UXTH     r5,r0
                  |L3.72|
000048  f5b47fb6          CMP      r4,#0x16c             ;205
00004c  d8eb              BHI      |L3.38|
                  |L3.78|
00004e  bf00              NOP                            ;210
;;;214    		}   
;;;215    		calendar.w_year=temp1;//得到年份
000050  4829              LDR      r0,|L3.248|
000052  8085              STRH     r5,[r0,#4]
;;;216    		temp1=0;
000054  2500              MOVS     r5,#0
;;;217    		while(temp>=28)//超过了一个月
000056  e016              B        |L3.134|
                  |L3.88|
;;;218    		{
;;;219    			if(Is_Leap_Year(calendar.w_year)&&temp1==1)//当年是不是闰年/2月份
000058  4927              LDR      r1,|L3.248|
00005a  8888              LDRH     r0,[r1,#4]  ; calendar
00005c  f7fffffe          BL       Is_Leap_Year
000060  b130              CBZ      r0,|L3.112|
000062  2d01              CMP      r5,#1
000064  d104              BNE      |L3.112|
;;;220    			{
;;;221    				if(temp>=29)temp-=29;//闰年的秒钟数
000066  2c1d              CMP      r4,#0x1d
000068  d301              BCC      |L3.110|
00006a  3c1d              SUBS     r4,r4,#0x1d
00006c  e009              B        |L3.130|
                  |L3.110|
;;;222    				else break; 
00006e  e00c              B        |L3.138|
                  |L3.112|
;;;223    			}
;;;224    			else 
;;;225    			{
;;;226    				if(temp>=mon_table[temp1])temp-=mon_table[temp1];//平年
000070  4822              LDR      r0,|L3.252|
000072  5d40              LDRB     r0,[r0,r5]
000074  42a0              CMP      r0,r4
000076  d803              BHI      |L3.128|
000078  4820              LDR      r0,|L3.252|
00007a  5d40              LDRB     r0,[r0,r5]
00007c  1a24              SUBS     r4,r4,r0
00007e  e000              B        |L3.130|
                  |L3.128|
;;;227    				else break;
000080  e003              B        |L3.138|
                  |L3.130|
;;;228    			}
;;;229    			temp1++;  
000082  1c68              ADDS     r0,r5,#1
000084  b285              UXTH     r5,r0
                  |L3.134|
000086  2c1c              CMP      r4,#0x1c              ;217
000088  d2e6              BCS      |L3.88|
                  |L3.138|
00008a  bf00              NOP                            ;222
;;;230    		}
;;;231    		calendar.w_month=temp1+1;	//得到月份
00008c  1c68              ADDS     r0,r5,#1
00008e  491a              LDR      r1,|L3.248|
000090  7188              STRB     r0,[r1,#6]
;;;232    		calendar.w_date=temp+1;  	//得到日期 
000092  1c60              ADDS     r0,r4,#1
000094  71c8              STRB     r0,[r1,#7]
                  |L3.150|
;;;233    	}
;;;234    	temp=timecount%86400;     		//得到秒钟数   	   
000096  4816              LDR      r0,|L3.240|
000098  fbb6f1f0          UDIV     r1,r6,r0
00009c  fb006411          MLS      r4,r0,r1,r6
;;;235    	calendar.hour=temp/3600;     	//小时
0000a0  f44f6061          MOV      r0,#0xe10
0000a4  fbb4f0f0          UDIV     r0,r4,r0
0000a8  4913              LDR      r1,|L3.248|
0000aa  7008              STRB     r0,[r1,#0]
;;;236    	calendar.min=(temp%3600)/60; 	//分钟	
0000ac  f44f6061          MOV      r0,#0xe10
0000b0  fbb4f1f0          UDIV     r1,r4,r0
0000b4  fb004011          MLS      r0,r0,r1,r4
0000b8  213c              MOVS     r1,#0x3c
0000ba  fbb0f0f1          UDIV     r0,r0,r1
0000be  490e              LDR      r1,|L3.248|
0000c0  7048              STRB     r0,[r1,#1]
;;;237    	calendar.sec=(temp%3600)%60; 	//秒钟
0000c2  f44f6061          MOV      r0,#0xe10
0000c6  fbb4f1f0          UDIV     r1,r4,r0
0000ca  fb004011          MLS      r0,r0,r1,r4
0000ce  213c              MOVS     r1,#0x3c
0000d0  fbb0f2f1          UDIV     r2,r0,r1
0000d4  fb010012          MLS      r0,r1,r2,r0
0000d8  4907              LDR      r1,|L3.248|
0000da  7088              STRB     r0,[r1,#2]
;;;238    	calendar.week=RTC_Get_Week(calendar.w_year,calendar.w_month,calendar.w_date);//获取星期   
0000dc  460b              MOV      r3,r1
0000de  79da              LDRB     r2,[r3,#7]  ; calendar
0000e0  7999              LDRB     r1,[r3,#6]  ; calendar
0000e2  8898              LDRH     r0,[r3,#4]  ; calendar
0000e4  f7fffffe          BL       RTC_Get_Week
0000e8  4903              LDR      r1,|L3.248|
0000ea  7208              STRB     r0,[r1,#8]
;;;239    	return 0;
0000ec  2000              MOVS     r0,#0
;;;240    }	 
0000ee  bd70              POP      {r4-r6,pc}
;;;241    //获得现在是星期几
                          ENDP

                  |L3.240|
                          DCD      0x00015180
                  |L3.244|
                          DCD      daycnt
                  |L3.248|
                          DCD      calendar
                  |L3.252|
                          DCD      mon_table

                          AREA ||i.RTC_Get_Week||, CODE, READONLY, ALIGN=2

                  RTC_Get_Week PROC
;;;244    //返回值：星期号																						 
;;;245    u8 RTC_Get_Week(u16 year,u8 month,u8 day)
000000  b5f0              PUSH     {r4-r7,lr}
;;;246    {	
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;247    	u16 temp2;
;;;248    	u8 yearH,yearL;
;;;249    	
;;;250    	yearH=year/100;	yearL=year%100; 
000008  2064              MOVS     r0,#0x64
00000a  fb93f0f0          SDIV     r0,r3,r0
00000e  b2c6              UXTB     r6,r0
000010  2064              MOVS     r0,#0x64
000012  fb93f7f0          SDIV     r7,r3,r0
000016  fb003017          MLS      r0,r0,r7,r3
00001a  b2c1              UXTB     r1,r0
;;;251    	// 如果为21世纪,年份数加100  
;;;252    	if (yearH>19)yearL+=100;
00001c  2e13              CMP      r6,#0x13
00001e  dd02              BLE      |L4.38|
000020  f1010064          ADD      r0,r1,#0x64
000024  b2c1              UXTB     r1,r0
                  |L4.38|
;;;253    	// 所过闰年数只算1900年之后的  
;;;254    	temp2=yearL+yearL/4;
000026  4608              MOV      r0,r1
000028  17cf              ASRS     r7,r1,#31
00002a  eb017797          ADD      r7,r1,r7,LSR #30
00002e  eb0107a7          ADD      r7,r1,r7,ASR #2
000032  b2ba              UXTH     r2,r7
;;;255    	temp2=temp2%7; 
000034  2007              MOVS     r0,#7
000036  fb92f7f0          SDIV     r7,r2,r0
00003a  fb002017          MLS      r0,r0,r7,r2
00003e  b282              UXTH     r2,r0
;;;256    	temp2=temp2+day+table_week[month-1];
000040  1957              ADDS     r7,r2,r5
000042  1e60              SUBS     r0,r4,#1
000044  f8dfc02c          LDR      r12,|L4.116|
000048  f81c0000          LDRB     r0,[r12,r0]
00004c  4438              ADD      r0,r0,r7
00004e  b282              UXTH     r2,r0
;;;257    	if (yearL%4==0&&month<3)temp2--;
000050  17cf              ASRS     r7,r1,#31
000052  eb017797          ADD      r7,r1,r7,LSR #30
000056  10bf              ASRS     r7,r7,#2
000058  eba10787          SUB      r7,r1,r7,LSL #2
00005c  b91f              CBNZ     r7,|L4.102|
00005e  2c03              CMP      r4,#3
000060  da01              BGE      |L4.102|
000062  1e50              SUBS     r0,r2,#1
000064  b282              UXTH     r2,r0
                  |L4.102|
;;;258    	return(temp2%7);
000066  2007              MOVS     r0,#7
000068  fb92f7f0          SDIV     r7,r2,r0
00006c  fb002017          MLS      r0,r0,r7,r2
000070  b2c0              UXTB     r0,r0
;;;259    }			  
000072  bdf0              POP      {r4-r7,pc}
;;;260    
                          ENDP

                  |L4.116|
                          DCD      table_week

                          AREA ||i.RTC_IRQHandler||, CODE, READONLY, ALIGN=1

                  RTC_IRQHandler PROC
;;;72     //extern u16 tcnt; 
;;;73     void RTC_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;74     {		 
;;;75     	if (RTC_GetITStatus(RTC_IT_SEC) != RESET)//秒钟中断
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       RTC_GetITStatus
000008  b108              CBZ      r0,|L5.14|
;;;76     	{							
;;;77     		RTC_Get();//更新时间   
00000a  f7fffffe          BL       RTC_Get
                  |L5.14|
;;;78      	}
;;;79     	if(RTC_GetITStatus(RTC_IT_ALR)!= RESET)//闹钟中断
00000e  2002              MOVS     r0,#2
000010  f7fffffe          BL       RTC_GetITStatus
000014  b120              CBZ      r0,|L5.32|
;;;80     	{
;;;81     		RTC_ClearITPendingBit(RTC_IT_ALR);		//清闹钟中断	  	
000016  2002              MOVS     r0,#2
000018  f7fffffe          BL       RTC_ClearITPendingBit
;;;82     	  RTC_Get();				//更新时间
00001c  f7fffffe          BL       RTC_Get
                  |L5.32|
;;;83     /*********************************************************/
;;;84     //		time_show();
;;;85     /**********************************************************/
;;;86       	//printf("Alarm Time:%d-%d-%d %d:%d:%d\n",\
;;;87     			calendar.w_year,\
;;;88     			calendar.w_month,\
;;;89     			calendar.w_date,\
;;;90     			calendar.hour,\
;;;91     			calendar.min,\
;;;92     			calendar.sec);//输出闹铃时间	
;;;93     		
;;;94       	} 				  								 
;;;95     	RTC_ClearITPendingBit(RTC_IT_SEC|RTC_IT_OW);		//清闹钟中断
000020  2005              MOVS     r0,#5
000022  f7fffffe          BL       RTC_ClearITPendingBit
;;;96     	RTC_WaitForLastTask();	  	    						 	   	 
000026  f7fffffe          BL       RTC_WaitForLastTask
;;;97     }
00002a  bd10              POP      {r4,pc}
;;;98     //判断是否是闰年函数
                          ENDP


                          AREA ||i.RTC_Init||, CODE, READONLY, ALIGN=1

                  RTC_Init PROC
;;;28     
;;;29     u8 RTC_Init(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;30     {
;;;31     	//检查是不是第一次配置时钟
;;;32     	u8 temp=0;
000002  2400              MOVS     r4,#0
;;;33     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);	//使能PWR和BKP外设时钟   
000004  2101              MOVS     r1,#1
000006  f04f50c0          MOV      r0,#0x18000000
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;34     	PWR_BackupAccessCmd(ENABLE);	//使能后备寄存器访问  
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       PWR_BackupAccessCmd
;;;35     	if (BKP_ReadBackupRegister(BKP_DR1) != 0x5050)		//从指定的后备寄存器中读出数据:读出了与写入的指定数据不相乎
000014  2004              MOVS     r0,#4
000016  f7fffffe          BL       BKP_ReadBackupRegister
00001a  f2450150          MOV      r1,#0x5050
00001e  4288              CMP      r0,r1
000020  d040              BEQ      |L6.164|
;;;36     		{	 			
;;;37     		BKP_DeInit();	//复位备份区域 	
000022  f7fffffe          BL       BKP_DeInit
;;;38     		RCC_LSEConfig(RCC_LSE_ON);	//设置外部低速晶振(LSE),使用外设低速晶振
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       RCC_LSEConfig
;;;39     		while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET&&temp<250)	//检查指定的RCC标志位设置与否,等待低速晶振就绪
00002c  e004              B        |L6.56|
                  |L6.46|
;;;40     			{
;;;41     			temp++;
00002e  1c60              ADDS     r0,r4,#1
000030  b2c4              UXTB     r4,r0
;;;42     			delay_ms(10);
000032  200a              MOVS     r0,#0xa
000034  f7fffffe          BL       delay_ms
                  |L6.56|
000038  2041              MOVS     r0,#0x41              ;39
00003a  f7fffffe          BL       RCC_GetFlagStatus
00003e  b908              CBNZ     r0,|L6.68|
000040  2cfa              CMP      r4,#0xfa              ;39
000042  dbf4              BLT      |L6.46|
                  |L6.68|
;;;43     			}
;;;44     		if(temp>=250)return 1;//初始化时钟失败,晶振有问题	    
000044  2cfa              CMP      r4,#0xfa
000046  db01              BLT      |L6.76|
000048  2001              MOVS     r0,#1
                  |L6.74|
;;;45     		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);		//设置RTC时钟(RTCCLK),选择LSE作为RTC时钟    
;;;46     		RCC_RTCCLKCmd(ENABLE);	//使能RTC时钟  
;;;47     		RTC_WaitForLastTask();	//等待最近一次对RTC寄存器的写操作完成
;;;48     		RTC_WaitForSynchro();		//等待RTC寄存器同步  
;;;49     		RTC_ITConfig(RTC_IT_SEC, ENABLE);		//使能RTC秒中断
;;;50     		RTC_WaitForLastTask();	//等待最近一次对RTC寄存器的写操作完成
;;;51     		RTC_EnterConfigMode();/// 允许配置	
;;;52     		RTC_SetPrescaler(32767); //设置RTC预分频的值
;;;53     		RTC_WaitForLastTask();	//等待最近一次对RTC寄存器的写操作完成
;;;54     		RTC_Set(2017,9,21,19,30,55);  //设置时间	
;;;55     		RTC_ExitConfigMode(); //退出配置模式  
;;;56     		BKP_WriteBackupRegister(BKP_DR1, 0X5050);	//向指定的后备寄存器中写入用户程序数据
;;;57     		}
;;;58     	else//系统继续计时
;;;59     		{
;;;60     
;;;61     		RTC_WaitForSynchro();	//等待最近一次对RTC寄存器的写操作完成
;;;62     		RTC_ITConfig(RTC_IT_SEC, ENABLE);	//使能RTC秒中断
;;;63     		RTC_WaitForLastTask();	//等待最近一次对RTC寄存器的写操作完成
;;;64     		}
;;;65     	RTC_NVIC_Config();//RCT中断分组设置		    				     
;;;66     	RTC_Get();//更新时间	
;;;67     	return 0; //ok
;;;68     
;;;69     }		 				    
00004a  bd1c              POP      {r2-r4,pc}
                  |L6.76|
00004c  f44f7080          MOV      r0,#0x100             ;45
000050  f7fffffe          BL       RCC_RTCCLKConfig
000054  2001              MOVS     r0,#1                 ;46
000056  f7fffffe          BL       RCC_RTCCLKCmd
00005a  f7fffffe          BL       RTC_WaitForLastTask
00005e  f7fffffe          BL       RTC_WaitForSynchro
000062  2101              MOVS     r1,#1                 ;49
000064  4608              MOV      r0,r1                 ;49
000066  f7fffffe          BL       RTC_ITConfig
00006a  f7fffffe          BL       RTC_WaitForLastTask
00006e  f7fffffe          BL       RTC_EnterConfigMode
000072  f64770ff          MOV      r0,#0x7fff            ;52
000076  f7fffffe          BL       RTC_SetPrescaler
00007a  f7fffffe          BL       RTC_WaitForLastTask
00007e  2037              MOVS     r0,#0x37              ;54
000080  211e              MOVS     r1,#0x1e              ;54
000082  2313              MOVS     r3,#0x13              ;54
000084  2215              MOVS     r2,#0x15              ;54
000086  e9cd1000          STRD     r1,r0,[sp,#0]         ;54
00008a  2109              MOVS     r1,#9                 ;54
00008c  f24070e1          MOV      r0,#0x7e1             ;54
000090  f7fffffe          BL       RTC_Set
000094  f7fffffe          BL       RTC_ExitConfigMode
000098  f2450150          MOV      r1,#0x5050            ;56
00009c  2004              MOVS     r0,#4                 ;56
00009e  f7fffffe          BL       BKP_WriteBackupRegister
0000a2  e007              B        |L6.180|
                  |L6.164|
0000a4  f7fffffe          BL       RTC_WaitForSynchro
0000a8  2101              MOVS     r1,#1                 ;62
0000aa  4608              MOV      r0,r1                 ;62
0000ac  f7fffffe          BL       RTC_ITConfig
0000b0  f7fffffe          BL       RTC_WaitForLastTask
                  |L6.180|
0000b4  f7fffffe          BL       RTC_NVIC_Config
0000b8  f7fffffe          BL       RTC_Get
0000bc  2000              MOVS     r0,#0                 ;67
0000be  e7c4              B        |L6.74|
;;;70     //RTC时钟中断
                          ENDP


                          AREA ||i.RTC_NVIC_Config||, CODE, READONLY, ALIGN=1

                  RTC_NVIC_Config PROC
;;;12      
;;;13     static void RTC_NVIC_Config(void)
000000  b508              PUSH     {r3,lr}
;;;14     {	
;;;15       NVIC_InitTypeDef NVIC_InitStructure;
;;;16     	NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;		//RTC全局中断
000002  2003              MOVS     r0,#3
000004  f88d0000          STRB     r0,[sp,#0]
;;;17     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;	//先占优先级1位,从优先级3位
000008  2000              MOVS     r0,#0
00000a  f88d0001          STRB     r0,[sp,#1]
;;;18     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;	//先占优先级0位,从优先级4位
00000e  f88d0002          STRB     r0,[sp,#2]
;;;19     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;		//使能该通道中断
000012  2001              MOVS     r0,#1
000014  f88d0003          STRB     r0,[sp,#3]
;;;20     	NVIC_Init(&NVIC_InitStructure);		//根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       NVIC_Init
;;;21     }
00001e  bd08              POP      {r3,pc}
;;;22     
                          ENDP


                          AREA ||i.RTC_Set||, CODE, READONLY, ALIGN=2

                  RTC_Set PROC
;;;123    const u8 mon_table[12]={31,28,31,30,31,30,31,31,30,31,30,31};
;;;124    u8 RTC_Set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;125    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;126    	u16 t;
;;;127    	u32 seccount=0;
000010  2400              MOVS     r4,#0
;;;128    	if(syear<1970||syear>2099)return 1;	   
000012  f24070b2          MOV      r0,#0x7b2
000016  4286              CMP      r6,r0
000018  db03              BLT      |L8.34|
00001a  f6400033          MOV      r0,#0x833
00001e  4286              CMP      r6,r0
000020  dd02              BLE      |L8.40|
                  |L8.34|
000022  2001              MOVS     r0,#1
                  |L8.36|
;;;129    	for(t=1970;t<syear;t++)	//把所有年份的秒钟相加
;;;130    	{
;;;131    		if(Is_Leap_Year(t))seccount+=31622400;//闰年的秒钟数
;;;132    		else seccount+=31536000;			  //平年的秒钟数
;;;133    	}
;;;134    	smon-=1;
;;;135    	for(t=0;t<smon;t++)	   //把前面月份的秒钟数相加
;;;136    	{
;;;137    		seccount+=(u32)mon_table[t]*86400;//月份秒钟数相加
;;;138    		if(Is_Leap_Year(syear)&&t==1)seccount+=86400;//闰年2月份增加一天的秒钟数	   
;;;139    	}
;;;140    	seccount+=(u32)(sday-1)*86400;//把前面日期的秒钟数相加 
;;;141    	seccount+=(u32)hour*3600;//小时秒钟数
;;;142        seccount+=(u32)min*60;	 //分钟秒钟数
;;;143    	seccount+=sec;//最后的秒钟加上去
;;;144    
;;;145    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);	//使能PWR和BKP外设时钟  
;;;146    	PWR_BackupAccessCmd(ENABLE);	//使能RTC和后备寄存器访问 
;;;147    	RTC_SetCounter(seccount);	//设置RTC计数器的值
;;;148    
;;;149    	RTC_WaitForLastTask();	//等待最近一次对RTC寄存器的写操作完成  	
;;;150    	return 0;	    
;;;151    }
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.40|
000028  f24075b2          MOV      r5,#0x7b2             ;129
00002c  e00a              B        |L8.68|
                  |L8.46|
00002e  4628              MOV      r0,r5                 ;131
000030  f7fffffe          BL       Is_Leap_Year
000034  b110              CBZ      r0,|L8.60|
000036  4820              LDR      r0,|L8.184|
000038  4404              ADD      r4,r4,r0              ;131
00003a  e001              B        |L8.64|
                  |L8.60|
00003c  481f              LDR      r0,|L8.188|
00003e  4404              ADD      r4,r4,r0              ;132
                  |L8.64|
000040  1c68              ADDS     r0,r5,#1              ;129
000042  b285              UXTH     r5,r0                 ;129
                  |L8.68|
000044  42b5              CMP      r5,r6                 ;129
000046  dbf2              BLT      |L8.46|
000048  1e78              SUBS     r0,r7,#1              ;134
00004a  b2c7              UXTB     r7,r0                 ;134
00004c  2500              MOVS     r5,#0                 ;135
00004e  e010              B        |L8.114|
                  |L8.80|
000050  481b              LDR      r0,|L8.192|
000052  5d40              LDRB     r0,[r0,r5]            ;137
000054  f24021a3          MOV      r1,#0x2a3             ;137
000058  4348              MULS     r0,r1,r0              ;137
00005a  eb0414c0          ADD      r4,r4,r0,LSL #7       ;137
00005e  4630              MOV      r0,r6                 ;138
000060  f7fffffe          BL       Is_Leap_Year
000064  b118              CBZ      r0,|L8.110|
000066  2d01              CMP      r5,#1                 ;138
000068  d101              BNE      |L8.110|
00006a  4816              LDR      r0,|L8.196|
00006c  4404              ADD      r4,r4,r0              ;138
                  |L8.110|
00006e  1c68              ADDS     r0,r5,#1              ;135
000070  b285              UXTH     r5,r0                 ;135
                  |L8.114|
000072  42bd              CMP      r5,r7                 ;135
000074  dbec              BLT      |L8.80|
000076  f1a80001          SUB      r0,r8,#1              ;140
00007a  f24021a3          MOV      r1,#0x2a3             ;140
00007e  4348              MULS     r0,r1,r0              ;140
000080  eb0414c0          ADD      r4,r4,r0,LSL #7       ;140
000084  ebc91049          RSB      r0,r9,r9,LSL #5       ;141
000088  ebc02009          RSB      r0,r0,r9,LSL #8       ;141
00008c  eb041400          ADD      r4,r4,r0,LSL #4       ;141
000090  ebca100a          RSB      r0,r10,r10,LSL #4     ;142
000094  eb040480          ADD      r4,r4,r0,LSL #2       ;142
000098  445c              ADD      r4,r4,r11             ;143
00009a  2101              MOVS     r1,#1                 ;145
00009c  f04f50c0          MOV      r0,#0x18000000        ;145
0000a0  f7fffffe          BL       RCC_APB1PeriphClockCmd
0000a4  2001              MOVS     r0,#1                 ;146
0000a6  f7fffffe          BL       PWR_BackupAccessCmd
0000aa  4620              MOV      r0,r4                 ;147
0000ac  f7fffffe          BL       RTC_SetCounter
0000b0  f7fffffe          BL       RTC_WaitForLastTask
0000b4  2000              MOVS     r0,#0                 ;150
0000b6  e7b5              B        |L8.36|
;;;152    
                          ENDP

                  |L8.184|
                          DCD      0x01e28500
                  |L8.188|
                          DCD      0x01e13380
                  |L8.192|
                          DCD      mon_table
                  |L8.196|
                          DCD      0x00015180

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  calendar
                          %        10

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  table_week
000000  00030306          DCB      0x00,0x03,0x03,0x06
000004  01040602          DCB      0x01,0x04,0x06,0x02
000008  05000305          DCB      0x05,0x00,0x03,0x05
                  mon_table
00000c  1f1c1f1e          DCB      0x1f,0x1c,0x1f,0x1e
000010  1f1e1f1f          DCB      0x1f,0x1e,0x1f,0x1f
000014  1e1f1e1f          DCB      0x1e,0x1f,0x1e,0x1f

                          AREA ||.data||, DATA, ALIGN=1

                  daycnt
000000  0000              DCW      0x0000
