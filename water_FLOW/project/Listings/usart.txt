; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=..\obj\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\main -I..\component\delay -I..\component\LED -I..\component\sys -I..\component\usart -I..\STM32_lib\CORE -I..\STM32_lib\inc -I..\STM32_lib\user_layer -I..\component\KEY -I..\component\lcd_driver -I..\component\gui -I..\component\UI -I..\component\RTC -I..\component\FreeRTOS\Source\include -I..\component\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\component\FreeRTOS -I..\component\FreeRTOS\Source\portable\MemMang -I..\component\FreeRTOS\Source\CMSIS_RTOS -I..\component\STMFLASH -I..\component\PWM_in -IE:\1.项目\1.水流量计\water_FLOW\project\RTE -ID:\1.Software_\5.Keil5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\1.Software_\5.Keil5\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -Dwater_flow --omf_browse=..\obj\usart.crf ..\component\usart\usart.c]
                          THUMB

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;98     **********************************************************/
;;;99     void USART1_IRQHandler(void)                	
000000  b510              PUSH     {r4,lr}
;;;100    	{
;;;101    	  u8 Res;
;;;102    
;;;103    		if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  //接收中断
000002  f2405125          MOV      r1,#0x525
000006  4804              LDR      r0,|L1.24|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b118              CBZ      r0,|L1.22|
;;;104    			{
;;;105    				Res =USART_ReceiveData(USART1);	//读取接收到的数据
00000e  4802              LDR      r0,|L1.24|
000010  f7fffffe          BL       USART_ReceiveData
000014  b2c4              UXTB     r4,r0
                  |L1.22|
;;;106    		
;;;107         } 
;;;108    
;;;109    } 
000016  bd10              POP      {r4,pc}
;;;110    
                          ENDP

                  |L1.24|
                          DCD      0x40013800

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;26     //定义_sys_exit()以避免使用半主机模式    
;;;27     _sys_exit(int x) 
000000  4601              MOV      r1,r0
;;;28     { 
;;;29     	x = x; 
000002  bf00              NOP      
;;;30     } 
000004  4770              BX       lr
;;;31     //重定义fputc函数 
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;31     //重定义fputc函数 
;;;32     int fputc(int ch, FILE *f)
000000  bf00              NOP      
                  |L3.2|
;;;33     {      
;;;34     	while((USART1->SR&0X40)==0) {};//循环发送,直到发送完毕   
000002  4a05              LDR      r2,|L3.24|
000004  8812              LDRH     r2,[r2,#0]
000006  f0020240          AND      r2,r2,#0x40
00000a  2a00              CMP      r2,#0
00000c  d0f9              BEQ      |L3.2|
;;;35         USART1->DR = (u8) ch;      
00000e  b2c2              UXTB     r2,r0
000010  4b01              LDR      r3,|L3.24|
000012  1d1b              ADDS     r3,r3,#4
000014  801a              STRH     r2,[r3,#0]
;;;36     	return ch;
;;;37     }
000016  4770              BX       lr
;;;38     #endif 
                          ENDP

                  |L3.24|
                          DCD      0x40013800

                          AREA ||i.uart_init||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;52     **********************************************************/
;;;53     void uart_init(u32 bound)
000000  b510              PUSH     {r4,lr}
;;;54     {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;55       //GPIO端口设置
;;;56       GPIO_InitTypeDef GPIO_InitStructure;
;;;57     	USART_InitTypeDef USART_InitStructure;
;;;58     	NVIC_InitTypeDef NVIC_InitStructure;
;;;59     	 
;;;60     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE);	//使能USART1，GPIOA时钟
000006  2101              MOVS     r1,#1
000008  f2440004          MOV      r0,#0x4004
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;61       
;;;62     	//USART1_TX   GPIOA.9
;;;63       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9
000010  f44f7000          MOV      r0,#0x200
000014  f8ad0014          STRH     r0,[sp,#0x14]
;;;64       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2003              MOVS     r0,#3
00001a  f88d0016          STRB     r0,[sp,#0x16]
;;;65       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
00001e  2018              MOVS     r0,#0x18
000020  f88d0017          STRB     r0,[sp,#0x17]
;;;66       GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.9
000024  a905              ADD      r1,sp,#0x14
000026  481d              LDR      r0,|L4.156|
000028  f7fffffe          BL       GPIO_Init
;;;67        
;;;68       //USART1_RX	  GPIOA.10初始化
;;;69       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10
00002c  f44f6080          MOV      r0,#0x400
000030  f8ad0014          STRH     r0,[sp,#0x14]
;;;70       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
000034  2004              MOVS     r0,#4
000036  f88d0017          STRB     r0,[sp,#0x17]
;;;71       GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.10  
00003a  a905              ADD      r1,sp,#0x14
00003c  4817              LDR      r0,|L4.156|
00003e  f7fffffe          BL       GPIO_Init
;;;72     
;;;73       //Usart1 NVIC 配置
;;;74       NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000042  2025              MOVS     r0,#0x25
000044  f88d0000          STRB     r0,[sp,#0]
;;;75     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=4 ;//抢占优先级3
000048  2004              MOVS     r0,#4
00004a  f88d0001          STRB     r0,[sp,#1]
;;;76     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;		//子优先级3
00004e  2003              MOVS     r0,#3
000050  f88d0002          STRB     r0,[sp,#2]
;;;77     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
000054  2001              MOVS     r0,#1
000056  f88d0003          STRB     r0,[sp,#3]
;;;78     	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
00005a  4668              MOV      r0,sp
00005c  f7fffffe          BL       NVIC_Init
;;;79       
;;;80        //USART 初始化设置
;;;81     
;;;82     	USART_InitStructure.USART_BaudRate = bound;//串口波特率
000060  9401              STR      r4,[sp,#4]
;;;83     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
000062  2000              MOVS     r0,#0
000064  f8ad0008          STRH     r0,[sp,#8]
;;;84     	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
000068  f8ad000a          STRH     r0,[sp,#0xa]
;;;85     	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
00006c  f8ad000c          STRH     r0,[sp,#0xc]
;;;86     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
000070  f8ad0010          STRH     r0,[sp,#0x10]
;;;87     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
000074  200c              MOVS     r0,#0xc
000076  f8ad000e          STRH     r0,[sp,#0xe]
;;;88     
;;;89       USART_Init(USART1, &USART_InitStructure); //初始化串口1
00007a  a901              ADD      r1,sp,#4
00007c  4808              LDR      r0,|L4.160|
00007e  f7fffffe          BL       USART_Init
;;;90       USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断
000082  2201              MOVS     r2,#1
000084  f2405125          MOV      r1,#0x525
000088  4805              LDR      r0,|L4.160|
00008a  f7fffffe          BL       USART_ITConfig
;;;91       USART_Cmd(USART1, ENABLE);                    //使能串口1 
00008e  2101              MOVS     r1,#1
000090  4803              LDR      r0,|L4.160|
000092  f7fffffe          BL       USART_Cmd
;;;92     
;;;93     }
000096  b006              ADD      sp,sp,#0x18
000098  bd10              POP      {r4,pc}
;;;94     /*********************************************************
                          ENDP

00009a  0000              DCW      0x0000
                  |L4.156|
                          DCD      0x40010800
                  |L4.160|
                          DCD      0x40013800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USART_RX_BUF
                          %        200

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
                  USART_RX_STA
000004  0000              DCW      0x0000
